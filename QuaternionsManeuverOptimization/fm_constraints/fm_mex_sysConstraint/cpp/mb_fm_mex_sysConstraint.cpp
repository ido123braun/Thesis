//
// Academic License - for use in teaching, academic research, and meeting
// course requirements at degree granting institutions only.  Not for
// government, commercial, or other organizational use.
//
// mb_fm_mex_sysConstraint.cpp
//
// Code generation for function 'mb_fm_mex_sysConstraint'
//

// Include files
#include "mb_fm_mex_sysConstraint.h"
#include <cmath>
#include <cstring>

// Function Definitions
void mb_fm_mex_sysConstraint(const double[16], const double states[14],
                             const double[3], double constraintvalue[2],
                             double j_constraintvalue[66])
{
  static const signed char iv[256]{
      1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1};
  static const signed char iv1[196]{
      1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1};
  static const signed char iv2[9]{1, 0, 0, 0, 1, 0, 0, 0, 1};
  double dv[66];
  double j_constraintvaluetmp[66];
  double constraintvalue_tmp;
  int i;
  int i1;
  int j_outputs_tmp;
  signed char b_j_outputs[1089];
  signed char j_outputs[528];
  signed char j_states[462];
  signed char j_controls[99];
  // mb_fm_mex_sysConstraint
  //  File automatically generated by FALCON.m
  // === Extract Data From Input ==============================================
  // === Jacobians and Hessians ===============================================
  std::memset(&j_outputs[0], 0, 528U * sizeof(signed char));
  for (i = 0; i < 16; i++) {
    for (i1 = 0; i1 < 16; i1++) {
      j_outputs_tmp = i1 + (i << 4);
      j_outputs[j_outputs_tmp] = iv[j_outputs_tmp];
    }
  }
  std::memset(&j_states[0], 0, 462U * sizeof(signed char));
  for (i = 0; i < 14; i++) {
    for (i1 = 0; i1 < 14; i1++) {
      j_states[i1 + 14 * (i + 16)] = iv1[i1 + 14 * i];
    }
  }
  std::memset(&j_controls[0], 0, 99U * sizeof(signed char));
  for (i = 0; i < 3; i++) {
    j_outputs_tmp = 3 * (i + 30);
    j_controls[j_outputs_tmp] = iv2[3 * i];
    j_controls[j_outputs_tmp + 1] = iv2[3 * i + 1];
    j_controls[j_outputs_tmp + 2] = iv2[3 * i + 2];
  }
  // === Write Constants ======================================================
  // === Subsystem sysConstraint ==============================================
  //  Defined at ?
  //  Call sys_9bbbbd3c6987c2e9fd1e27f1b1183bfa_jac
  // SYS_9BBBBD3C6987C2E9FD1E27F1B1183BFA_JAC
  //     [OUT1,J_OUT1,H_OUT1] =
  //     SYS_9BBBBD3C6987C2E9FD1E27F1B1183BFA_JAC(IN1,IN2,IN3) This function was
  //     generated by the Symbolic Math Toolbox version 8.7. 17-Jan-2023
  //     20:53:11
  // Generated using CreateGradient
  // Input dimensions : {[16 1], [14 1], [3 1]}
  // Derivative inputs: [true true true]
  // DerivativeOrder  : 1
  // Output dimensions: {[2 1]}
  // Constant outputs : false
  constraintvalue[0] = ((states[6] * states[6] + states[7] * states[7]) +
                        states[8] * states[8]) +
                       states[9] * states[9];
  constraintvalue_tmp = std::sqrt(
      (states[3] * states[3] + states[4] * states[4]) + states[5] * states[5]);
  constraintvalue[1] = constraintvalue_tmp;
  //  Hessian Jacobian for sys_9bbbbd3c6987c2e9fd1e27f1b1183bfa_jac
  //  Calculation of Jacobian with respect to function global input for
  //  sys_9bbbbd3c6987c2e9fd1e27f1b1183bfa_jac
  std::memset(&dv[0], 0, 39U * sizeof(double));
  dv[39] = states[3] / constraintvalue_tmp;
  dv[40] = 0.0;
  dv[41] = states[4] / constraintvalue_tmp;
  dv[42] = 0.0;
  dv[43] = states[5] / constraintvalue_tmp;
  dv[44] = states[6] * 2.0;
  dv[45] = 0.0;
  dv[46] = states[7] * 2.0;
  dv[47] = 0.0;
  dv[48] = states[8] * 2.0;
  dv[49] = 0.0;
  dv[50] = states[9] * 2.0;
  std::memset(&dv[51], 0, 15U * sizeof(double));
  for (i = 0; i < 33; i++) {
    for (i1 = 0; i1 < 16; i1++) {
      b_j_outputs[i1 + 33 * i] = j_outputs[i1 + (i << 4)];
    }
    for (i1 = 0; i1 < 14; i1++) {
      b_j_outputs[(i1 + 33 * i) + 16] = j_states[i1 + 14 * i];
    }
    b_j_outputs[33 * i + 30] = j_controls[3 * i];
    b_j_outputs[33 * i + 31] = j_controls[3 * i + 1];
    b_j_outputs[33 * i + 32] = j_controls[3 * i + 2];
  }
  for (i = 0; i < 2; i++) {
    for (i1 = 0; i1 < 33; i1++) {
      constraintvalue_tmp = 0.0;
      for (j_outputs_tmp = 0; j_outputs_tmp < 33; j_outputs_tmp++) {
        constraintvalue_tmp +=
            dv[i + (j_outputs_tmp << 1)] *
            static_cast<double>(b_j_outputs[j_outputs_tmp + 33 * i1]);
      }
      j_constraintvaluetmp[i + (i1 << 1)] = constraintvalue_tmp;
    }
  }
  //  Combine Variables to constraintvalue
  for (i = 0; i < 33; i++) {
    j_outputs_tmp = i << 1;
    j_constraintvalue[j_outputs_tmp] = j_constraintvaluetmp[j_outputs_tmp];
    j_constraintvalue[j_outputs_tmp + 1] =
        j_constraintvaluetmp[j_outputs_tmp + 1];
  }
}

void mb_fm_mex_sysConstraint_initialize()
{
}

void mb_fm_mex_sysConstraint_terminate()
{
  // (no terminate code required)
}

// End of code generation (mb_fm_mex_sysConstraint.cpp)
