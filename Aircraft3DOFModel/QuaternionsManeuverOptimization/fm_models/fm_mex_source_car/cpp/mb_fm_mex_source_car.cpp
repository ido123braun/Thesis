//
// Academic License - for use in teaching, academic research, and meeting
// course requirements at degree granting institutions only.  Not for
// government, commercial, or other organizational use.
//
// mb_fm_mex_source_car.cpp
//
// Code generation for function 'mb_fm_mex_source_car'
//

// Include files
#include "mb_fm_mex_source_car.h"
#include <cmath>
#include <cstring>

// Function Definitions
void mb_fm_mex_source_car(const double states[4], const double controls[2],
                          double statesdot[4], double outputs[2],
                          double j_statesdot[24], double j_outputs[12])
{
  static const signed char b_a[6]{0, 0, 1, 0, 0, 0};
  double dv[24];
  double j_statedottmp[24];
  double a[6];
  double b_controls;
  double b_out1_tmp;
  double b_states;
  double c_controls;
  double c_states;
  double out1_tmp;
  int i;
  int j_statesdot_tmp;
  signed char tmp_j_input_sys_6581733cc9ff0ec32f2da6105b085807[36];
  signed char j_V[6];
  signed char j_Vdot[6];
  signed char j_chi[6];
  signed char j_chidot[6];
  signed char j_x[6];
  signed char j_y[6];
  // mb_fm_mex_source_car
  //  File automatically generated by FALCON.m
  // === Extract Data From Input ==============================================
  // === Jacobians and Hessians ===============================================
  for (i = 0; i < 6; i++) {
    j_x[i] = 0;
  }
  j_x[0] = 1;
  for (i = 0; i < 6; i++) {
    j_y[i] = 0;
  }
  j_y[1] = 1;
  for (i = 0; i < 6; i++) {
    j_V[i] = 0;
  }
  j_V[2] = 1;
  for (i = 0; i < 6; i++) {
    j_chi[i] = 0;
  }
  j_chi[3] = 1;
  for (i = 0; i < 6; i++) {
    j_Vdot[i] = 0;
  }
  j_Vdot[4] = 1;
  for (i = 0; i < 6; i++) {
    j_chidot[i] = 0;
  }
  j_chidot[5] = 1;
  //  Combine Variables to states
  b_states = states[2];
  c_states = states[3];
  //  Combine Variables to controls
  b_controls = controls[0];
  c_controls = controls[1];
  // === Write Constants ======================================================
  // === Call sys_6581733cc9ff0ec32f2da6105b085807 ============================
  // SYS_6581733CC9FF0EC32F2DA6105B085807
  //     [OUT1,OUT2,OUT3,J_OUT1,J_OUT2,J_OUT3,H_OUT1,H_OUT2,H_OUT3] =
  //     SYS_6581733CC9FF0EC32F2DA6105B085807(IN1,IN2) This function was
  //     generated by the Symbolic Math Toolbox version 8.7. 25-Mar-2022
  //     18:01:48
  out1_tmp = std::sin(c_states);
  b_out1_tmp = std::cos(c_states);
  statesdot[0] = b_states * b_out1_tmp;
  statesdot[1] = b_states * out1_tmp;
  statesdot[2] = b_controls;
  statesdot[3] = c_controls;
  //  Hessian Jacobian for sys_6581733cc9ff0ec32f2da6105b085807
  for (i = 0; i < 6; i++) {
    tmp_j_input_sys_6581733cc9ff0ec32f2da6105b085807[6 * i] = j_x[i];
    tmp_j_input_sys_6581733cc9ff0ec32f2da6105b085807[6 * i + 1] = j_y[i];
    tmp_j_input_sys_6581733cc9ff0ec32f2da6105b085807[6 * i + 2] = j_V[i];
    tmp_j_input_sys_6581733cc9ff0ec32f2da6105b085807[6 * i + 3] = j_chi[i];
    tmp_j_input_sys_6581733cc9ff0ec32f2da6105b085807[6 * i + 4] = j_Vdot[i];
    tmp_j_input_sys_6581733cc9ff0ec32f2da6105b085807[6 * i + 5] = j_chidot[i];
  }
  //  Calculation of Jacobian with respect to function global input for
  //  sys_6581733cc9ff0ec32f2da6105b085807
  std::memset(&dv[0], 0, 8U * sizeof(double));
  dv[8] = b_out1_tmp;
  dv[9] = out1_tmp;
  dv[10] = 0.0;
  dv[11] = 0.0;
  dv[12] = -b_states * out1_tmp;
  b_controls = b_states * std::cos(c_states);
  dv[13] = b_controls;
  dv[14] = 0.0;
  dv[15] = 0.0;
  dv[16] = 0.0;
  dv[17] = 0.0;
  dv[18] = 1.0;
  dv[19] = 0.0;
  dv[20] = 0.0;
  dv[21] = 0.0;
  dv[22] = 0.0;
  dv[23] = 1.0;
  for (i = 0; i < 4; i++) {
    for (j_statesdot_tmp = 0; j_statesdot_tmp < 6; j_statesdot_tmp++) {
      c_controls = 0.0;
      for (int i1{0}; i1 < 6; i1++) {
        c_controls +=
            dv[i + (i1 << 2)] *
            static_cast<double>(tmp_j_input_sys_6581733cc9ff0ec32f2da6105b085807
                                    [i1 + 6 * j_statesdot_tmp]);
      }
      j_statedottmp[i + (j_statesdot_tmp << 2)] = c_controls;
    }
  }
  //  Combine Variables to statesdot
  //  Combine Variables to outputs
  outputs[0] = b_states * std::sin(c_states);
  outputs[1] = b_states + 1.0;
  a[0] = 0.0;
  a[1] = 0.0;
  a[2] = out1_tmp;
  a[3] = b_controls;
  a[4] = 0.0;
  a[5] = 0.0;
  for (i = 0; i < 6; i++) {
    j_statesdot_tmp = i << 2;
    j_statesdot[j_statesdot_tmp] = j_statedottmp[j_statesdot_tmp];
    j_statesdot[j_statesdot_tmp + 1] = j_statedottmp[j_statesdot_tmp + 1];
    j_statesdot[j_statesdot_tmp + 2] = j_statedottmp[j_statesdot_tmp + 2];
    j_statesdot[j_statesdot_tmp + 3] = j_statedottmp[j_statesdot_tmp + 3];
    b_controls = 0.0;
    c_controls = 0.0;
    for (j_statesdot_tmp = 0; j_statesdot_tmp < 6; j_statesdot_tmp++) {
      signed char i2;
      i2 = tmp_j_input_sys_6581733cc9ff0ec32f2da6105b085807[j_statesdot_tmp +
                                                            6 * i];
      b_controls += a[j_statesdot_tmp] * static_cast<double>(i2);
      c_controls += static_cast<double>(b_a[j_statesdot_tmp] * i2);
    }
    j_statesdot_tmp = i << 1;
    j_outputs[j_statesdot_tmp] = b_controls;
    j_outputs[j_statesdot_tmp + 1] = c_controls;
  }
}

void mb_fm_mex_source_car_initialize()
{
}

void mb_fm_mex_source_car_terminate()
{
  // (no terminate code required)
}

// End of code generation (mb_fm_mex_source_car.cpp)
