//
// Academic License - for use in teaching, academic research, and meeting
// course requirements at degree granting institutions only.  Not for
// government, commercial, or other organizational use.
//
// mb_fm_mex_FBC.cpp
//
// Code generation for function 'mb_fm_mex_FBC'
//

// Include files
#include "mb_fm_mex_FBC.h"
#include <cstring>

// Function Definitions
void mb_fm_mex_FBC(const double states[12], const double[3], double constant_1,
                   double *constraintvalue, double j_constraintvalue[15])
{
  static const signed char iv[144]{
      1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1};
  static const signed char a[15]{0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
  static const signed char iv1[9]{1, 0, 0, 0, 1, 0, 0, 0, 1};
  int i;
  int j_controls_tmp;
  signed char b_j_states[225];
  signed char j_states[180];
  signed char j_controls[45];
  // mb_fm_mex_FBC
  //  File automatically generated by FALCON.m
  // === Extract Data From Input ==============================================
  // === Jacobians and Hessians ===============================================
  std::memset(&j_states[0], 0, 180U * sizeof(signed char));
  for (i = 0; i < 12; i++) {
    for (j_controls_tmp = 0; j_controls_tmp < 12; j_controls_tmp++) {
      int j_states_tmp;
      j_states_tmp = j_controls_tmp + 12 * i;
      j_states[j_states_tmp] = iv[j_states_tmp];
    }
  }
  for (i = 0; i < 45; i++) {
    j_controls[i] = 0;
  }
  for (i = 0; i < 3; i++) {
    j_controls_tmp = 3 * (i + 12);
    j_controls[j_controls_tmp] = iv1[3 * i];
    j_controls[j_controls_tmp + 1] = iv1[3 * i + 1];
    j_controls[j_controls_tmp + 2] = iv1[3 * i + 2];
  }
  // === Write Constants ======================================================
  // === Subsystem FBC ========================================================
  //  Defined at ?
  //  Call sys_5a3e1ea0ce79a4748bce5750a4ae9f28_jac
  // SYS_5A3E1EA0CE79A4748BCE5750A4AE9F28_JAC
  //     [OUT1,J_OUT1,H_OUT1] =
  //     SYS_5A3E1EA0CE79A4748BCE5750A4AE9F28_JAC(IN1,IN2,NDIN1VAL1) This
  //     function was generated by the Symbolic Math Toolbox version 8.7.
  //     22-Mar-2023 14:08:11
  // Generated using CreateGradient
  // Input dimensions : {[12 1], [3 1], [1 1]}
  // Derivative inputs: [true true false]
  // DerivativeOrder  : 1
  // Output dimensions: {[1 1]}
  // Constant outputs : false
  *constraintvalue = states[2] - constant_1;
  //  Hessian Jacobian for sys_5a3e1ea0ce79a4748bce5750a4ae9f28_jac
  //  Calculation of Jacobian with respect to function global input for
  //  sys_5a3e1ea0ce79a4748bce5750a4ae9f28_jac
  for (i = 0; i < 15; i++) {
    double d;
    for (j_controls_tmp = 0; j_controls_tmp < 12; j_controls_tmp++) {
      b_j_states[j_controls_tmp + 15 * i] = j_states[j_controls_tmp + 12 * i];
    }
    b_j_states[15 * i + 12] = j_controls[3 * i];
    b_j_states[15 * i + 13] = j_controls[3 * i + 1];
    b_j_states[15 * i + 14] = j_controls[3 * i + 2];
    d = 0.0;
    for (j_controls_tmp = 0; j_controls_tmp < 15; j_controls_tmp++) {
      d += static_cast<double>(a[j_controls_tmp] *
                               b_j_states[j_controls_tmp + 15 * i]);
    }
    j_constraintvalue[i] = d;
  }
  //  Combine Variables to constraintvalue
}

void mb_fm_mex_FBC_initialize()
{
}

void mb_fm_mex_FBC_terminate()
{
  // (no terminate code required)
}

// End of code generation (mb_fm_mex_FBC.cpp)
