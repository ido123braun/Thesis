//
// Academic License - for use in teaching, academic research, and meeting
// course requirements at degree granting institutions only.  Not for
// government, commercial, or other organizational use.
//
// mb_fm_mex_sysConstraint.cpp
//
// Code generation for function 'mb_fm_mex_sysConstraint'
//

// Include files
#include "mb_fm_mex_sysConstraint.h"
#include <cstring>

// Function Definitions
void mb_fm_mex_sysConstraint(const double[10], const double states[12],
                             const double[3], double *constraintvalue,
                             double j_constraintvalue[25])
{
  static const signed char iv1[144]{
      1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1};
  static const signed char iv[100]{
      1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1};
  static const signed char iv2[9]{1, 0, 0, 0, 1, 0, 0, 0, 1};
  double dv[25];
  int i;
  int j_controls_tmp;
  signed char b_j_outputs[625];
  signed char j_states[300];
  signed char j_outputs[250];
  signed char j_controls[75];
  // mb_fm_mex_sysConstraint
  //  File automatically generated by FALCON.m
  // === Extract Data From Input ==============================================
  // === Jacobians and Hessians ===============================================
  std::memset(&j_outputs[0], 0, 250U * sizeof(signed char));
  for (i = 0; i < 10; i++) {
    for (j_controls_tmp = 0; j_controls_tmp < 10; j_controls_tmp++) {
      int j_outputs_tmp;
      j_outputs_tmp = j_controls_tmp + 10 * i;
      j_outputs[j_outputs_tmp] = iv[j_outputs_tmp];
    }
  }
  std::memset(&j_states[0], 0, 300U * sizeof(signed char));
  for (i = 0; i < 12; i++) {
    for (j_controls_tmp = 0; j_controls_tmp < 12; j_controls_tmp++) {
      j_states[j_controls_tmp + 12 * (i + 10)] = iv1[j_controls_tmp + 12 * i];
    }
  }
  std::memset(&j_controls[0], 0, 75U * sizeof(signed char));
  for (i = 0; i < 3; i++) {
    j_controls_tmp = 3 * (i + 22);
    j_controls[j_controls_tmp] = iv2[3 * i];
    j_controls[j_controls_tmp + 1] = iv2[3 * i + 1];
    j_controls[j_controls_tmp + 2] = iv2[3 * i + 2];
  }
  // === Write Constants ======================================================
  // === Subsystem sysConstraint ==============================================
  //  Defined at ?
  //  Call sys_7940c2593334abb4279bf2c7ccd9b43c_jac
  // SYS_7940C2593334ABB4279BF2C7CCD9B43C_JAC
  //     [OUT1,J_OUT1,H_OUT1] =
  //     SYS_7940C2593334ABB4279BF2C7CCD9B43C_JAC(IN1,IN2,IN3) This function was
  //     generated by the Symbolic Math Toolbox version 8.7. 26-Jan-2023
  //     17:22:08
  // Generated using CreateGradient
  // Input dimensions : {[10 1], [12 1], [3 1]}
  // Derivative inputs: [true true true]
  // DerivativeOrder  : 1
  // Output dimensions: {[1 1]}
  // Constant outputs : false
  *constraintvalue = ((states[4] * states[4] + states[5] * states[5]) +
                      states[6] * states[6]) +
                     states[7] * states[7];
  //  Hessian Jacobian for sys_7940c2593334abb4279bf2c7ccd9b43c_jac
  //  Calculation of Jacobian with respect to function global input for
  //  sys_7940c2593334abb4279bf2c7ccd9b43c_jac
  std::memset(&dv[0], 0, 14U * sizeof(double));
  dv[14] = states[4] * 2.0;
  dv[15] = states[5] * 2.0;
  dv[16] = states[6] * 2.0;
  dv[17] = states[7] * 2.0;
  dv[18] = 0.0;
  dv[19] = 0.0;
  dv[20] = 0.0;
  dv[21] = 0.0;
  dv[22] = 0.0;
  dv[23] = 0.0;
  dv[24] = 0.0;
  for (i = 0; i < 25; i++) {
    double d;
    for (j_controls_tmp = 0; j_controls_tmp < 10; j_controls_tmp++) {
      b_j_outputs[j_controls_tmp + 25 * i] = j_outputs[j_controls_tmp + 10 * i];
    }
    for (j_controls_tmp = 0; j_controls_tmp < 12; j_controls_tmp++) {
      b_j_outputs[(j_controls_tmp + 25 * i) + 10] =
          j_states[j_controls_tmp + 12 * i];
    }
    b_j_outputs[25 * i + 22] = j_controls[3 * i];
    b_j_outputs[25 * i + 23] = j_controls[3 * i + 1];
    b_j_outputs[25 * i + 24] = j_controls[3 * i + 2];
    d = 0.0;
    for (j_controls_tmp = 0; j_controls_tmp < 25; j_controls_tmp++) {
      d += dv[j_controls_tmp] *
           static_cast<double>(b_j_outputs[j_controls_tmp + 25 * i]);
    }
    j_constraintvalue[i] = d;
  }
  //  Combine Variables to constraintvalue
}

void mb_fm_mex_sysConstraint_initialize()
{
}

void mb_fm_mex_sysConstraint_terminate()
{
  // (no terminate code required)
}

// End of code generation (mb_fm_mex_sysConstraint.cpp)
